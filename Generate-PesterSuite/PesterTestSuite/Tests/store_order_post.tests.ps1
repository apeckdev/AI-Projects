#Requires -Modules Pester

<#
.SYNOPSIS
    Pester tests for the POST /store/order endpoint.
    Generated by Generate-PesterFromOpenAPI.ps1 script.
#>

param(
    # Base URL for the API. Default attempts to read from environment variable.
    [string]$BaseUrl = $env:API_BASE_URL, # Use backticks to escape $

    # API Key if needed for authentication. Default attempts to read from environment variable.
    [string]$ApiKey = $env:API_KEY # Use backticks to escape $ - Modify or remove if using different auth
)

BeforeAll {
    if ([string]::IsNullOrWhiteSpace($BaseUrl)) { # Use backtick to escape $
        # Use backticks to escape  and 
        Write-Warning "API Base URL ($env:API_BASE_URL or -BaseUrl parameter) is not set. Tests will likely fail."
        # You might want to throw here to stop execution if BaseUrl is mandatory
        # throw "API Base URL is required."
    }
    # Add other setup tasks if needed (e.g., check for API Key)
    # if ([string]::IsNullOrWhiteSpace($ApiKey)) {
    #     Write-Warning "API Key ($env:API_KEY or -ApiKey parameter) is not set. Authentication tests might fail."
    # }
}

Describe "POST /store/order Endpoint Tests" -Tags 'POST', 'store' { # POST, /store/order, 'POST', 'store' are expanded by the *generator*

    Context "Basic POST Request" { # POST expanded by the *generator*

        It "Should return a successful status code (2xx)" {
            # TODO: Handle path parameters (e.g., replace {id} with a valid value) if '/store/order' contains them.
            $requestPath = '/store/order' # Use backtick for literal . /store/order is expanded by the generator.

            # Example Parameter Handling (Uncomment and adapt if needed):
            # if ($requestPath -match '\{(.+?)\}') { # Use backtick for literal 
            #     $paramName = $Matches[1] # Use backtick for literal , 
            #     Write-Warning "Test for path '/store/order' requires parameter '{$$paramName}'. Using placeholder '1'." # Escape $ for literal  output
            #     $requestPath = $requestPath -replace "\{\$$paramName\}", "1" # Use backtick for literal , escape $ for literal 
            # }

            # Use backticks for literal , ,  in the generated script
            $uri = "$BaseUrl$requestPath"

            # TODO: Add authentication headers if needed. Example for Bearer token:
            $headers = @{} # Use backtick for literal 
            # if (-not [string]::IsNullOrWhiteSpace($ApiKey)) { # Use backtick for literal 
            #    $headers.Add('Authorization', "Bearer $ApiKey") # Use backtick for literal , 
            # }
            # Or add API Key header directly:
            # if (-not [string]::IsNullOrWhiteSpace($ApiKey)) { # Use backtick for literal 
            #    $headers.Add('X-API-Key', $ApiKey) # Adjust header name as needed # Use backtick for literal , 
            # }

            # TODO: Add body for POST/PUT/PATCH methods if required.
            # $body = @{ key = 'value' } | ConvertTo-Json # Example body # Use backtick for literal 

            # Use backtick for literal  in the generated script's Write-Verbose
            Write-Verbose "Sending POST request to $uri" # POST expanded by generator

            try {
                # Use Invoke-WebRequest to easily access status code, even for non-2xx by default (though it throws on 4xx/5xx)
                # Use -SkipHttpErrorCheck with Invoke-RestMethod if you prefer that and want to check status manually for all cases
                # Ensure  and potentially  are defined correctly above this try block
                # Use backticks for literal , , . 'POST' is literal string here.  needs backtick if used.
                $response = Invoke-WebRequest -Uri $uri -Method 'POST' -Headers $headers -ErrorAction Stop # Add -Body $body if needed

                # Check if status code is in the 200-299 range
                # Use backtick for literal 
                $response.StatusCode | Should -BeInRange 200 299
            }
            catch {
                # If Invoke-WebRequest throws (likely 4xx or 5xx), fail the test and show the error
                # We want the literal '' in the output file. Escape the outer '$'.
                Write-Error "Request failed: $($_.Exception.Message)"
                # We want the literal '.Exception.Response' in the output file. Escape the '$'.
                if ($_.Exception.Response) {
                   # We want the literal '' in the output file. Escape the outer '$'.
                   Write-Error "Response Status Code: $($_.Exception.Response.StatusCode)"
                   # Try to get response body if available
                   try {
                       # We want the literal '.Exception.Response.GetResponseStream()' in the output file. Escape the '$'.
                       # Define literal  variable inside the catch block
                       $responseStream = $_.Exception.Response.GetResponseStream()
                       # Use literal  variable from *within* this catch block
                       $streamReader = New-Object System.IO.StreamReader($responseStream)
                       # Use literal  variable
                       $responseBody = $streamReader.ReadToEnd()
                       $streamReader.Close()
                       $responseStream.Close()
                       # Expand the variable  *within the generated script's context*. Escape the outer '$'.
                       Write-Error "Response Body: $($responseBody)"
                   } catch {
                       Write-Warning "Could not read response body from exception."
                   }
                } else {
                   Write-Warning "No response object found in the exception."
                }
                # Fail the test explicitly to make it clear
                # Expand the variable  *within the generated script's context*. Escape the outer '$'.
                Throw "Request to $($uri) failed."
            }
        }

        # TODO: Add more basic tests as needed.
        # It "Should return the correct Content-Type" {
        #     # ... similar request logic ...
        #     # Note: Invoke-WebRequest response object has Headers property
        #     # $response = Invoke-WebRequest ... # Use backtick for literal 
        #     # $response.Headers.'Content-Type' | Should -Match 'application/json' # Adjust expected type # Use backtick for literal 
        # }
    }
}
